<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agent åƒç´ å°äºº - å“”å“”ç›®æ ‡ä»ªè¡¨ç›˜</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #1a1a1a;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }
    #game-container {
      border: 2px solid #00ff00;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    }
    #status-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #00ff00;
      padding: 15px;
      color: #00ff00;
      font-size: 12px;
      max-width: 300px;
      border-radius: 5px;
    }
    .agent-status {
      margin: 5px 0;
      padding: 5px;
      border-left: 3px solid;
    }
    .status-idle { border-color: #00ff00; }
    .status-busy { border-color: #ff9900; }
    .status-inactive { border-color: #666666; }
    .status-error { border-color: #ff0000; }
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ff00;
      font-size: 18px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div>ğŸ® åŠ è½½ä¸­...</div>
    <div style="font-size: 12px; margin-top: 10px;">æ­£åœ¨åŠ è½½ 56 å¼ è§’è‰²å›¾...</div>
  </div>
  
  <div id="status-panel">
    <h3 style="margin-top: 0;">ğŸ“¡ Agent çŠ¶æ€</h3>
    <div id="agent-list"></div>
    <div style="margin-top: 10px; font-size: 10px; opacity: 0.7;">
      æ›´æ–°æ—¶é—´: <span id="update-time">--:--:--</span>
    </div>
  </div>
  
  <div id="game-container"></div>

  <script>
    // Agent é…ç½®ï¼ˆ7 ä¸ªè§’è‰²ï¼‰
    const AGENT_CONFIG = {
      bibi: { name: 'å“”å“”', emoji: 'ğŸ“¡', x: 100, y: 150 },
      lingtian: { name: 'é›¶å¤©', emoji: 'âš™ï¸', x: 250, y: 150 },
      xiayan: { name: 'å¤è¨€', emoji: 'ğŸƒ', x: 400, y: 150 },
      boran: { name: 'åšç‡ƒ', emoji: 'ğŸ’°', x: 550, y: 150 },
      huaxian: { name: 'ç”»ä»™', emoji: 'ğŸ¨', x: 175, y: 350 },
      yanan: { name: 'éªŒå®‰', emoji: 'ğŸ›¡ï¸', x: 400, y: 350 },
      shuxian: { name: 'ä¹¦ä»™', emoji: 'ğŸ“–', x: 550, y: 350 }
    };

    // Phaser é…ç½®
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 600,
      parent: 'game-container',
      backgroundColor: '#2d2d2d',
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false
        }
      }
    };

    const game = new Phaser.Game(config);
    let agents = {};
    let agentData = [];

    function preload() {
      console.log('ğŸ® å¼€å§‹åŠ è½½è§’è‰²å›¾...');
      
      // è·å–å½“å‰é¡µé¢çš„åŸºç¡€è·¯å¾„
      const basePath = window.location.pathname.replace(/\/[^\/]*$/, '');
      
      // ç”Ÿæˆæ‰€æœ‰å›¾ç‰‡çš„åŠ è½½åˆ—è¡¨
      const imagesToLoad = [];
      for (const agentId in AGENT_CONFIG) {
        const directions = ['down', 'up', 'left', 'right'];
        const actions = ['idle', 'walk'];
        
        actions.forEach(action => {
          directions.forEach(dir => {
            imagesToLoad.push({
              key: `${agentId}-${action}-${dir}`,
              path: `${basePath}/assets/ancient-style-64/${agentId}-${action}-${dir}.png`
            });
          });
        });
      }
      
      // åˆ†æ‰¹åŠ è½½ï¼ˆæ¯æ‰¹ 5 å¼ ï¼‰
      const batchSize = 5;
      for (let i = 0; i < imagesToLoad.length; i += batchSize) {
        const batch = imagesToLoad.slice(i, i + batchSize);
        
        setTimeout(() => {
          batch.forEach(img => {
            console.log(`[${Math.floor(i/batchSize)+1}/${Math.ceil(imagesToLoad.length/batchSize)}] Loading: ${img.key}`);
            this.load.image(img.key, img.path);
          });
        }, (i / batchSize) * 500); // æ¯æ‰¹é—´éš” 500ms
      }
      
      // æ·»åŠ åŠ è½½é”™è¯¯å¤„ç†
      this.load.on('loaderror', (file) => {
        console.error('Failed to load:', file.src);
      });
      
      // æ·»åŠ åŠ è½½æˆåŠŸæ—¥å¿—
      this.load.on('filecomplete', (key) => {
        console.log('âœ… Loaded:', key);
      });
    }

    function create() {
      console.log('ğŸ® åœºæ™¯åˆ›å»ºå®Œæˆ');
      document.getElementById('loading').style.display = 'none';

      // åˆ›å»º 7 ä¸ª agent ç²¾çµ
      for (const [agentId, config] of Object.entries(AGENT_CONFIG)) {
        // åˆ›å»ºç²¾çµï¼ˆé»˜è®¤æ˜¾ç¤º idle-downï¼‰
        const sprite = this.physics.add.sprite(config.x, config.y, `${agentId}-idle-down`);
        sprite.setScale(1.5); // æ”¾å¤§ 1.5 å€
        
        // åˆ›å»ºåå­—æ ‡ç­¾
        const nameText = this.add.text(config.x, config.y + 60, config.name, {
          fontSize: '14px',
          color: '#ffffff',
          fontFamily: 'Courier New',
          stroke: '#000000',
          strokeThickness: 3
        }).setOrigin(0.5);

        // åˆ›å»ºçŠ¶æ€å›¾æ ‡
        const statusIcon = this.add.text(config.x, config.y - 60, 'ğŸ§', {
          fontSize: '24px'
        }).setOrigin(0.5);

        // ä¿å­˜å¼•ç”¨
        agents[agentId] = {
          sprite: sprite,
          nameText: nameText,
          statusIcon: statusIcon,
          originalX: config.x,
          originalY: config.y,
          status: 'idle',
          direction: 'down',
          isWalking: false,
          walkTimer: 0,
          targetX: config.x,
          targetY: config.y
        };
      }

      // å®šæ—¶ä» API æ‹‰å–çŠ¶æ€
      this.time.addEvent({
        delay: 5000,
        callback: updateAgentStates,
        callbackScope: this,
        loop: true
      });

      // ç«‹å³æ‹‰å–ä¸€æ¬¡
      updateAgentStates.call(this);

      // æ·»åŠ éšæœºè¡Œä¸ºå®šæ—¶å™¨ï¼ˆé—²é€›ï¼‰
      this.time.addEvent({
        delay: 3000,
        callback: randomWalk,
        callbackScope: this,
        loop: true
      });
    }

    function update() {
      // æ›´æ–°æ¯ä¸ª agent çš„ä½ç½®å’ŒåŠ¨ç”»
      for (const [agentId, agent] of Object.entries(agents)) {
        // åŒæ­¥åå­—å’ŒçŠ¶æ€å›¾æ ‡ä½ç½®
        agent.nameText.x = agent.sprite.x;
        agent.nameText.y = agent.sprite.y + 60;
        agent.statusIcon.x = agent.sprite.x;
        agent.statusIcon.y = agent.sprite.y - 60;

        // å¦‚æœæ­£åœ¨è¡Œèµ°ï¼Œç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
        if (agent.isWalking) {
          const dx = agent.targetX - agent.sprite.x;
          const dy = agent.targetY - agent.sprite.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 5) {
            // åˆ°è¾¾ç›®æ ‡ï¼Œåœæ­¢è¡Œèµ°
            agent.isWalking = false;
            agent.sprite.setTexture(`${agentId}-idle-${agent.direction}`);
          } else {
            // ç»§ç»­ç§»åŠ¨
            const speed = 2;
            agent.sprite.x += (dx / distance) * speed;
            agent.sprite.y += (dy / distance) * speed;

            // æ›´æ–°æ–¹å‘
            if (Math.abs(dx) > Math.abs(dy)) {
              agent.direction = dx > 0 ? 'right' : 'left';
            } else {
              agent.direction = dy > 0 ? 'down' : 'up';
            }

            // æ›´æ–°è¡Œèµ°åŠ¨ç”»
            agent.sprite.setTexture(`${agentId}-walk-${agent.direction}`);
          }
        }
      }
    }

    // ä» API æ‹‰å– agent çŠ¶æ€
    async function updateAgentStates() {
      try {
        const response = await fetch('/api/openclaw/agents');
        const data = await response.json();
        
        if (data.status === 'ok') {
          agentData = data.agents;
          
          // æ›´æ–°æ¯ä¸ª agent çš„çŠ¶æ€
          data.agents.forEach(agentInfo => {
            const agent = agents[agentInfo.id];
            if (agent) {
              agent.status = agentInfo.status;
              
              // æ›´æ–°çŠ¶æ€å›¾æ ‡
              switch (agentInfo.status) {
                case 'busy':
                  agent.statusIcon.setText('ğŸƒ');
                  break;
                case 'idle':
                  agent.statusIcon.setText('ğŸ§');
                  break;
                case 'inactive':
                  agent.statusIcon.setText('ğŸ’¤');
                  break;
                case 'error':
                  agent.statusIcon.setText('âš ï¸');
                  break;
              }
            }
          });

          // æ›´æ–°çŠ¶æ€é¢æ¿
          updateStatusPanel(data.agents);
        }
      } catch (error) {
        console.error('Failed to fetch agent status:', error);
      }
    }

    // æ›´æ–°çŠ¶æ€é¢æ¿
    function updateStatusPanel(agents) {
      const agentList = document.getElementById('agent-list');
      const updateTime = document.getElementById('update-time');
      
      agentList.innerHTML = agents.map(agent => `
        <div class="agent-status status-${agent.status}">
          ${agent.emoji} ${agent.name}: ${getStatusText(agent.status)}
          ${agent.currentTask ? `<br><small>â†’ ${agent.currentTask}</small>` : ''}
        </div>
      `).join('');
      
      const now = new Date();
      updateTime.textContent = now.toLocaleTimeString('zh-CN');
    }

    function getStatusText(status) {
      const statusMap = {
        idle: 'ç©ºé—²',
        busy: 'å¿™ç¢Œä¸­',
        inactive: 'ä¸æ´»è·ƒ',
        error: 'æŠ¥é”™'
      };
      return statusMap[status] || status;
    }

    // éšæœºè¡Œèµ°ï¼ˆé—²é€›ï¼‰
    function randomWalk() {
      for (const [agentId, agent] of Object.entries(agents)) {
        // åªæœ‰ç©ºé—²çš„ agent æ‰ä¼šé—²é€›
        if (agent.status === 'idle' && !agent.isWalking && Math.random() < 0.3) {
          // éšæœºç›®æ ‡ä½ç½®ï¼ˆåœ¨åŸä½ç½®é™„è¿‘ï¼‰
          agent.targetX = agent.originalX + (Math.random() - 0.5) * 200;
          agent.targetY = agent.originalY + (Math.random() - 0.5) * 150;
          
          // è¾¹ç•Œé™åˆ¶
          agent.targetX = Math.max(100, Math.min(700, agent.targetX));
          agent.targetY = Math.max(100, Math.min(500, agent.targetY));
          
          agent.isWalking = true;
        }
      }
    }
  </script>
</body>
</html>
